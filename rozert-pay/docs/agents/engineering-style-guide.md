# Гайд По Стилю Разработки (Для Агента)

## Размещение бизнес-логики

- Бизнес-сценарии размещать в модулях `services`.
- Модели, serializers, views и admin должны оставаться тонкими.

## Соглашения по Django-моделям

- Новые доменные модели по умолчанию строить на `BaseDjangoModel`, если нет явной причины иначе.
- Публичный/внешний идентификатор хранить отдельным полем `uuid` (`unique=True`), не заменяя внутренний `id`.
- Поля статусов и типов хранить через `TextChoices` или константы, а не через свободные строки.
- Для денежных значений использовать `MoneyField`.
- Не ослаблять семантику `on_delete` для финансовой истории (`PROTECT`, где требуется целостность истории).
- Инварианты модели проверять в `clean()` (комбинации полей, scope, уникальность активных правил).
- Для аудита сохранять используемый паттерн:
  - `AuditlogHistoryField`
  - `auditlog.register(...)`
- Для административных срезов предпочитать proxy-модели и manager-фильтрацию, а не дублирование таблиц.
- Для PII-полей использовать существующие паттерны шифрования/хеширования (`EncryptedFieldV2` + deterministic hash).
- `BalanceTransaction` и связанные ledger-записи считать источником аудита; не вводить массовые обновления исторических данных.

## Правила работы с моделями

- Не обновлять `PaymentTransaction.status` напрямую вне регламентированного transaction-processing флоу.
- Для операций, меняющих финансовые сущности, использовать `transaction.atomic()` и `select_for_update()`.
- Внешние HTTP-вызовы не выполнять внутри открытой DB-транзакции.
- Celery-задачам передавать только идентификаторы и запускать их через `transaction.on_commit(...)`/`execute_on_commit(...)`.
- В hot-path использовать `select_related` / `prefetch_related`, чтобы избегать N+1.
- Для частичных обновлений использовать `save(update_fields=[...])`.
- Для обновлений JSON в `extra` использовать точечные DB-операции (`JSONFieldSetValueFunc` через `db_services.save_extra_field`), а не полную перезапись.

## Правила логирования

- Использовать модульный логгер: `logger = logging.getLogger(__name__)`.
- Писать структурированные логи через `extra={...}` и ключевые идентификаторы (`transaction_id`, `callback_id`, `request_id`, `system`, `status_code`).
- Использовать:
  - `logger.exception(...)` в блоках `except`;
  - `logger.warning(...)` для контролируемой деградации;
  - `logger.error(...)` для сценариев с ошибочным итогом операции.
- Никогда не логировать секреты, CVV, полный PAN, токены, приватные ключи и сырые персональные данные.
- Для внешних API логировать минимум: метод, URL, статус, длительность; полные тела писать только при строгой необходимости и в санитизированном виде.

## Политика Fail-Fast

- При невалидном состоянии/инварианте завершать сценарий явной ошибкой.
- Не скрывать ошибки через `except Exception: pass`.
- Критичные входные данные и зависимости валидировать как можно раньше (guard clauses).
- Инфраструктурные вызовы выполнять с явными таймаутами и ограниченными ретраями.
- Исключения перехватывать только для добавления контекста, маппинга в доменную ошибку или rollback/cleanup; при отсутствии безопасного recovery ошибка должна быть проброшена дальше.

## Именование и читаемость

- Имена должны быть самодостаточными. По имени должно быть понятно, *что это* или *какой результат дает функция*, без чтения окружающего кода.
- Функции именовать глаголами (`build_*`, `validate_*`, `calculate_*`), сущности - существительными.
- Для предикатов использовать `is_*`, `has_*`, `can_*` в зависимости от смысла проверки.
- Коллекции называть множественным числом (`users`, `errors`), а счетчики — `*_count` (`users_count`, `errors_count`).
- Не использовать слишком общие имена (`data`, `value`, `process`, `file`) там, где можно дать предметное имя (`filepath`, `domain_name`, `user_email`).
- Не использовать односимвольные имена переменных (`a`, `x`, `i`) в рабочем коде.
- Избегать венгерской нотации (`user_array`, `name_string`) и кодирования типа в имени.
- Использовать согласованные пары антонимов (`old/new`, `before/after`, `start/end`); не делать «полупары» вроде `value` и `new_value`.
- Сокращать только общеупотребимые вещи (`id`, `url`, `num`); избегать неочевидных сокращений (`empt`, `hid`).
- Не использовать транслитерацию в идентификаторах; имена в коде писать на английском.

## Явный доступ к атрибутам

- Не использовать динамический доступ к атрибутам (`getattr`, `setattr`, `hasattr`, `delattr`) в прикладном коде.
- Предпочитать явный доступ (`obj.field`, `obj.method()`) и явные ветки условий, чтобы поведение было читаемым и проверяемым статически.

## Дополнительные проектные паттерны

- Для внешних платежных интеграций использовать `ExternalApiSession` / `get_external_api_session`, чтобы сохранять покрытие event log и метрик.
- Для бизнес-критичных service-функций использовать `@track_duration("<scope>.<function>")`.
- Пользовательские строки держать на английском (ASCII-friendly policy).
- Для тестов платежного флоу использовать существующие фабрики/фикстуры из `tests/factories.py` и `tests/payment/conftest.py`.
